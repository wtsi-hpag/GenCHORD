#!/usr/bin/python3
import os
import re
def ReadSettings():
	
	# print(myDir)
	settings = []
	file = myDir + "/settings.dat"
	with open(file) as f:
		for line in f:
			line = line.rstrip().split("#")
			comment = ""
			if len(line) > 1:
				comment = "  /*" + "#".join(line[1:]) + "*/"
			q = re.split("\\s+",line[0].rstrip())
			
			if len(q) != 4:
				raise ValueError("Setting entries must have 4 elements; type, Name, default, key. They must be space-delimited.")
			if q[0] not in ["int","double","string","std::string","char","bool"]:
				raise ValueError(q[0] + " is not a valid type.")
			if q[0] == "string":
				q[0] = "std::string"
			if q[0] == "std::string" and q[2][0] != "\"":
				q[2] = f"\"{q[2]}\""
			if q[0] == "char" and q[2][0] != "\'":
				q[2] = f"\'{q[2]}\'"
			if q[3][0] != "\"":
				q[3] = f"\"{q[3]}\""
			settings.append(f"Setting({q[0]},{q[1]},{q[2]},{q[3]}){comment}\\")
	return settings

def FormatSettingsFile(settings):
	prelude = '''#pragma once\n#include \"JSL.h\"
/*
	IMPORTANT! 
	Settings are defined programmatically in settings.dat, and this file is then constructed using the settingBuilder.py file. 
	This avoids boilerplate bloat, and integrates command line settings with the help files automatically. 
	DO NOT EDIT THIS FILE!
*/
#define SETTINGS_LIST \\'''
	for setting in settings:
		prelude += "\n\t" + setting 
	
	text = prelude + "\n\n"
	outputfile = myDir + "/settings.h"
	adding = False
	with open(outputfile) as f:
		for line in f:
			if not adding:
				if "class" in line:
					adding = True

			if adding:
				text += line

	f = open(outputfile,"w")
	f.write(text)
	f.close()
	
if __name__ == "__main__":
	try:
		myDir = os.path.dirname((os.path.realpath(__file__)))
		settings = ReadSettings()
		FormatSettingsFile(settings)
	except Exception as e:
		print("SETTING-PARSE ERROR:", e)