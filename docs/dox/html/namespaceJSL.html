<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Deforester: JSL Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Deforester<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">JSL Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceJSL_1_1Fonts" id="r_namespaceJSL_1_1Fonts"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL_1_1Fonts.html">Fonts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceJSL_1_1internal" id="r_namespaceJSL_1_1internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceJSL_1_1LineProperties" id="r_namespaceJSL_1_1LineProperties"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL_1_1LineProperties.html">LineProperties</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1Argument.html">Argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1ArgumentInterface.html">ArgumentInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1Axis.html">Axis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1ColourArray.html">ColourArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1gnuplot.html">gnuplot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global interface for the plotting system. All calls should be piped through this individual class. Each gnuplot object corresponds to a single plot (though they might have severable axes within each plot)  <a href="classJSL_1_1gnuplot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structJSL_1_1mkdirReturn.html">mkdirReturn</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper for the return type of mkdirSafely()  <a href="structJSL_1_1mkdirReturn.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structJSL_1_1NameValuePair.html">NameValuePair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple struct for associating a datatype a member of <a class="el" href="namespaceJSL.html#ad5aeae8cb562d6f38c724cbdc51d81f8">JSL::Property</a>.  <a href="structJSL_1_1NameValuePair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1PlotData.html">PlotData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A holder class for the datalocation, and line specification for each plot added to an axis.  <a href="classJSL_1_1PlotData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1PredictionBar.html">PredictionBar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1ProgressBar.html">ProgressBar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1Toggle.html">Toggle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classJSL_1_1Toggle.html" title="A Toggle is a special case of an Argument which doesn&#39;t actually require an argument - that is,...">Toggle</a> is a special case of an <a class="el" href="classJSL_1_1Argument.html">Argument</a> which doesn't actually require an argument - that is, the presence of the flag is informative. A toggle is an <a class="el" href="classJSL_1_1Argument.html">Argument&lt;bool&gt;</a> object with a specialised constructor which looks only for the presence of the TriggerString.  <a href="classJSL_1_1Toggle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1UnitTest.html">UnitTest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classJSL_1_1Vector.html">Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a871354b683a8bee0151dbfbbde49beda" id="r_a871354b683a8bee0151dbfbbde49beda"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a871354b683a8bee0151dbfbbde49beda">PlotType</a> { <a class="el" href="namespaceJSL.html#a871354b683a8bee0151dbfbbde49bedaafa1098e16302d619cc16c6117128c7e2">Line</a>
, <a class="el" href="namespaceJSL.html#a871354b683a8bee0151dbfbbde49bedaa523747d04b06019ae6db545703793d22">ScatterPoint</a>
, <a class="el" href="namespaceJSL.html#a871354b683a8bee0151dbfbbde49bedaa18063242b9bed054d8672dd4efb6cd33">BarChart</a>
, <a class="el" href="namespaceJSL.html#a871354b683a8bee0151dbfbbde49bedaa5411aeb3b0211480c96c5d14e5e41e53">SurfaceMap</a>
 }</td></tr>
<tr class="separator:a871354b683a8bee0151dbfbbde49beda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aeae8cb562d6f38c724cbdc51d81f8" id="r_ad5aeae8cb562d6f38c724cbdc51d81f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ad5aeae8cb562d6f38c724cbdc51d81f8">Property</a> { <a class="el" href="namespaceJSL.html#ad5aeae8cb562d6f38c724cbdc51d81f8ae7660181e67b34cc8012e44899358c0a">Colour</a>
, <a class="el" href="namespaceJSL.html#ad5aeae8cb562d6f38c724cbdc51d81f8a22d189b48d50314bdd20b34e9a40e4a5">PenSize</a>
, <a class="el" href="namespaceJSL.html#ad5aeae8cb562d6f38c724cbdc51d81f8ab516e098813c27967b8e649b94f98db8">PenType</a>
, <a class="el" href="namespaceJSL.html#ad5aeae8cb562d6f38c724cbdc51d81f8afadeba2e8b035dc3c761f416c88a293d">Legend</a>
 }</td></tr>
<tr class="separator:ad5aeae8cb562d6f38c724cbdc51d81f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbabfae0b320d418d49485b7c50bc355" id="r_acbabfae0b320d418d49485b7c50bc355"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#acbabfae0b320d418d49485b7c50bc355">LineType</a> { <br />
&#160;&#160;<a class="el" href="namespaceJSL.html#acbabfae0b320d418d49485b7c50bc355aaf6d64d28f76aa54961a419d3d9e17b5">Solid</a>
, <a class="el" href="namespaceJSL.html#acbabfae0b320d418d49485b7c50bc355a5d77703e9d097677886b897d9a2eeb62">Dash</a>
, <a class="el" href="namespaceJSL.html#acbabfae0b320d418d49485b7c50bc355af0b887cb0d75c330317bc843146bfc92">DashDot</a>
, <a class="el" href="namespaceJSL.html#acbabfae0b320d418d49485b7c50bc355ac3cd9b153ce73b7d8dd0485ae186379d">Dotted</a>
, <br />
&#160;&#160;<a class="el" href="namespaceJSL.html#acbabfae0b320d418d49485b7c50bc355a48afd9609abb3d990c826b2c74850d3e">DashDotDot</a>
<br />
 }</td></tr>
<tr class="separator:acbabfae0b320d418d49485b7c50bc355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086efb36ddb107d45961a6b46932c526" id="r_a086efb36ddb107d45961a6b46932c526"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526">ScatterType</a> { <br />
&#160;&#160;<a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526a7d6491e51b0151fad51114bdc9fe0006">Dot</a>
, <a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526ac54fadde63eae4fbfb5090af9e2c8c68">Plus</a>
, <a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526af2349f50039f930d90a39a689282aaf8">Cross</a>
, <a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526a3d4283b7785e19142f43a8d705f45128">Star</a>
, <br />
&#160;&#160;<a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526af5af415948dea41c775febe11df59707">OpenSquare</a>
, <a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526ab2977a42bdf7f8cafd62d56eb573d71a">FilledSquare</a>
, <a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526a24102e043f642c5aadf0a5184838e065">OpenCircle</a>
, <a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526a1e5a2218783d5197e73aab6b16f3add3">FilledCircle</a>
, <br />
&#160;&#160;<a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526a163fb60ab5d5beca95d7afa4c97d6fda">OpenDelta</a>
, <a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526abc2204e7d338e5c0f3c5b524c3250352">FilledDelta</a>
, <a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526ae6f313a61f49260feabbe0252daebf39">OpenNabla</a>
, <a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526ac57738c0de5dcd2b52aedd0ac353fcd8">FilledNabla</a>
, <br />
&#160;&#160;<a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526aede7da49ec9867bc58a9883ac6f7fd12">OpenDiamond</a>
, <a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526a9ba302e97b23281952e4e194387808b2">FilledDiamond</a>
<br />
 }</td></tr>
<tr class="separator:a086efb36ddb107d45961a6b46932c526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5059dbafa288b9b3beac1746f4acae61" id="r_a5059dbafa288b9b3beac1746f4acae61"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61">ErrorCode</a> { <br />
&#160;&#160;<a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61a0a229ef32833c9a64ed38080ba87b196">JSLError</a>
, <a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61ab2e398994d8ffbb8c17109c9ec85ed30">SystemError</a>
, <a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61afec2ceb4545826a8594a9dc7a7b1c702">OverrunError</a>
, <a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61a007fec64442c721c18380cb70c51a443">FailedAssertion</a>
, <br />
&#160;&#160;<a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61a7da39e712d8960d161fbef3305d793a4">IOError</a>
, <a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61ae87e52367d118ac8a793c78a53ec9973">PlottingError</a>
<br />
 }</td></tr>
<tr class="memdesc:a5059dbafa288b9b3beac1746f4acae61"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of recognised <a class="el" href="namespaceJSL.html">JSL</a> errors.  <a href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61">More...</a><br /></td></tr>
<tr class="separator:a5059dbafa288b9b3beac1746f4acae61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a428e6ac7fa22e5c5aa3bceb9e17fe970" id="r_a428e6ac7fa22e5c5aa3bceb9e17fe970"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; </td></tr>
<tr class="memitem:a428e6ac7fa22e5c5aa3bceb9e17fe970"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">int</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a428e6ac7fa22e5c5aa3bceb9e17fe970">FindXInY</a> (<a class="el" href="structJSL_1_1NameValuePair.html">T</a> <a class="el" href="structJSL_1_1NameValuePair.html">x</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &amp;<a class="el" href="structJSL_1_1NameValuePair.html">y</a>)</td></tr>
<tr class="memdesc:a428e6ac7fa22e5c5aa3bceb9e17fe970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets first id such that y[id] == x, assuming that exact equality is well defined (see double override). If no such id exists, returns negative value.  <br /></td></tr>
<tr class="separator:a428e6ac7fa22e5c5aa3bceb9e17fe970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab806e537ccfdea16b7d194d77cdb307e" id="r_ab806e537ccfdea16b7d194d77cdb307e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ab806e537ccfdea16b7d194d77cdb307e">FindXInY</a> (<a class="el" href="structJSL_1_1NameValuePair.html">double</a> <a class="el" href="structJSL_1_1NameValuePair.html">x</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt; &amp;<a class="el" href="structJSL_1_1NameValuePair.html">y</a>, <a class="el" href="structJSL_1_1NameValuePair.html">double</a> <a class="el" href="structJSL_1_1NameValuePair.html">tolerance</a>)</td></tr>
<tr class="memdesc:ab806e537ccfdea16b7d194d77cdb307e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets first id such that (y[id]- x)/x &lt; tolerance. If no such id exists, returns negative value.  <br /></td></tr>
<tr class="separator:ab806e537ccfdea16b7d194d77cdb307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d104ebd2bbb9ec6eade1abbb59fa84e" id="r_a1d104ebd2bbb9ec6eade1abbb59fa84e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">typename</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; </td></tr>
<tr class="memitem:a1d104ebd2bbb9ec6eade1abbb59fa84e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">size_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a1d104ebd2bbb9ec6eade1abbb59fa84e">SortIndices</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &amp;<a class="el" href="structJSL_1_1NameValuePair.html">v</a>)</td></tr>
<tr class="separator:a1d104ebd2bbb9ec6eade1abbb59fa84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3dd386e7ab4be6fae6e0bdf8c98e91" id="r_a6e3dd386e7ab4be6fae6e0bdf8c98e91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a6e3dd386e7ab4be6fae6e0bdf8c98e91">UpperBoundLocator</a> (<a class="el" href="structJSL_1_1NameValuePair.html">double</a> <a class="el" href="structJSL_1_1NameValuePair.html">val</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt; &amp;<a class="el" href="structJSL_1_1NameValuePair.html">valArray</a>)</td></tr>
<tr class="memdesc:a6e3dd386e7ab4be6fae6e0bdf8c98e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to FindXInY except where you do not expect an exact match. Searches through an (assumed sorted) vector and locates the first value greater than or equal to the target value, else returns the index of the final value in the array.  <br /></td></tr>
<tr class="separator:a6e3dd386e7ab4be6fae6e0bdf8c98e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96050c622f5d29373cdc4a5ebb216b47" id="r_a96050c622f5d29373cdc4a5ebb216b47"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; </td></tr>
<tr class="memitem:a96050c622f5d29373cdc4a5ebb216b47"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a96050c622f5d29373cdc4a5ebb216b47">operator&lt;&lt;</a> (std::ostream &amp;<a class="el" href="structJSL_1_1NameValuePair.html">os</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Argument.html">Argument</a>&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; <a class="el" href="structJSL_1_1NameValuePair.html">a</a>)</td></tr>
<tr class="memdesc:a96050c622f5d29373cdc4a5ebb216b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an explicit instruction for how to infer outputting the arg-value. This works (temperamentally) without this function, but strings (well-known for being fiddly here) can sometimes mess it up, so providing explicit instruction works for the best.  <br /></td></tr>
<tr class="separator:a96050c622f5d29373cdc4a5ebb216b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405f53748ca024b70694b0534cfcf4a3" id="r_a405f53748ca024b70694b0534cfcf4a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a405f53748ca024b70694b0534cfcf4a3">jumpLineUp</a> ()</td></tr>
<tr class="memdesc:a405f53748ca024b70694b0534cfcf4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the last linebreak character, jumping the cursor up one line.  <br /></td></tr>
<tr class="separator:a405f53748ca024b70694b0534cfcf4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071b279ad5267ce66ff86c614952a3ed" id="r_a071b279ad5267ce66ff86c614952a3ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a071b279ad5267ce66ff86c614952a3ed">clearScreen</a> ()</td></tr>
<tr class="memdesc:a071b279ad5267ce66ff86c614952a3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to calling the "clear" command on the shell, removes all text on the terminal, and returns the cursor to the home position.  <br /></td></tr>
<tr class="separator:a071b279ad5267ce66ff86c614952a3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38780f94d60045b904b289eb3ab8eda" id="r_ae38780f94d60045b904b289eb3ab8eda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ae38780f94d60045b904b289eb3ab8eda">deleteLine</a> ()</td></tr>
<tr class="memdesc:ae38780f94d60045b904b289eb3ab8eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last line of text, moving the cursor from its current position, to the beginning of the line. If you want to remove the linebreak which caused that line to exist in the first place, must be followed up with <a class="el" href="namespaceJSL.html#a405f53748ca024b70694b0534cfcf4a3" title="Deletes the last linebreak character, jumping the cursor up one line.">jumpLineUp()</a>. ALternatively, if a linebreak has been printed and you want to delete that line <em>first</em>, you must call <a class="el" href="namespaceJSL.html#a405f53748ca024b70694b0534cfcf4a3" title="Deletes the last linebreak character, jumping the cursor up one line.">jumpLineUp()</a> before <a class="el" href="namespaceJSL.html#ae38780f94d60045b904b289eb3ab8eda" title="Removes the last line of text, moving the cursor from its current position, to the beginning of the l...">deleteLine()</a>.  <br /></td></tr>
<tr class="separator:ae38780f94d60045b904b289eb3ab8eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d8cb112d513ee5a3ae38ca6a89743d" id="r_a47d8cb112d513ee5a3ae38ca6a89743d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a47d8cb112d513ee5a3ae38ca6a89743d">initialiseFile</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">filename</a>)</td></tr>
<tr class="separator:a47d8cb112d513ee5a3ae38ca6a89743d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838b3a913896993bc008408d164ec19d" id="r_a838b3a913896993bc008408d164ec19d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a838b3a913896993bc008408d164ec19d">writeStringToFile</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">filename</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">content</a>)</td></tr>
<tr class="separator:a838b3a913896993bc008408d164ec19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d611217d83275af846cbc091ff98f53" id="r_a1d611217d83275af846cbc091ff98f53"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; </td></tr>
<tr class="memitem:a1d611217d83275af846cbc091ff98f53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a1d611217d83275af846cbc091ff98f53">writeVectorToFile</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">filename</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &amp;<a class="el" href="structJSL_1_1NameValuePair.html">contentVector</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">delimiter</a>, <a class="el" href="structJSL_1_1NameValuePair.html">bool</a> <a class="el" href="structJSL_1_1NameValuePair.html">includeTerminalLineBreak</a>)</td></tr>
<tr class="separator:a1d611217d83275af846cbc091ff98f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425710dc6536490f1c1d6a5ce621f0e3" id="r_a425710dc6536490f1c1d6a5ce621f0e3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">typename</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> , typename... Ts&gt; </td></tr>
<tr class="memitem:a425710dc6536490f1c1d6a5ce621f0e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a425710dc6536490f1c1d6a5ce621f0e3">writeMultiVectorToFile</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">filename</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">delimiter</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &amp;<a class="el" href="structJSL_1_1NameValuePair.html">v1</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">Ts</a> &gt; &amp;... <a class="el" href="structJSL_1_1NameValuePair.html">vecs</a>)</td></tr>
<tr class="separator:a425710dc6536490f1c1d6a5ce621f0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae790600d9f16e338cfc8b50cd1bfc8f4" id="r_ae790600d9f16e338cfc8b50cd1bfc8f4"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; </td></tr>
<tr class="memitem:ae790600d9f16e338cfc8b50cd1bfc8f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ae790600d9f16e338cfc8b50cd1bfc8f4">writeMatrixToFile</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">filename</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &gt; <a class="el" href="structJSL_1_1NameValuePair.html">contentMatrix</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">columnDelimiter</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rowDelimiter</a>)</td></tr>
<tr class="separator:ae790600d9f16e338cfc8b50cd1bfc8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245ac3bfe113c110491342bf2bb602fc" id="r_a245ac3bfe113c110491342bf2bb602fc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> , <a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">R</a> , <a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">S</a> &gt; </td></tr>
<tr class="memitem:a245ac3bfe113c110491342bf2bb602fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a245ac3bfe113c110491342bf2bb602fc">writeHeatMapToFile</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">filename</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">R</a> &gt; &amp;<a class="el" href="structJSL_1_1NameValuePair.html">x</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">S</a> &gt; &amp;<a class="el" href="structJSL_1_1NameValuePair.html">y</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &gt; <a class="el" href="structJSL_1_1NameValuePair.html">z</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">columnDelimiter</a>)</td></tr>
<tr class="separator:a245ac3bfe113c110491342bf2bb602fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7885f51066f38fb013d8065b97a3013d" id="r_a7885f51066f38fb013d8065b97a3013d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a7885f51066f38fb013d8065b97a3013d">jfglatex</a> (std::string <a class="el" href="structJSL_1_1NameValuePair.html">filename</a>, std::string <a class="el" href="structJSL_1_1NameValuePair.html">compilename</a>, <a class="el" href="structJSL_1_1NameValuePair.html">bool</a> <a class="el" href="structJSL_1_1NameValuePair.html">openfile</a>, <a class="el" href="structJSL_1_1NameValuePair.html">bool</a> <a class="el" href="structJSL_1_1NameValuePair.html">quietmode</a>)</td></tr>
<tr class="separator:a7885f51066f38fb013d8065b97a3013d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed873f557a849265f2197aa7a98d0da4" id="r_aed873f557a849265f2197aa7a98d0da4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#aed873f557a849265f2197aa7a98d0da4">LineCount</a> (std::string <a class="el" href="structJSL_1_1NameValuePair.html">file</a>)</td></tr>
<tr class="separator:aed873f557a849265f2197aa7a98d0da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1752cd7c6e1134da51e9307527e0d788" id="r_a1752cd7c6e1134da51e9307527e0d788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a1752cd7c6e1134da51e9307527e0d788">locationExists</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">filename</a>)</td></tr>
<tr class="separator:a1752cd7c6e1134da51e9307527e0d788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf525d02b8c49f21ef7faa68b7571f93" id="r_abf525d02b8c49f21ef7faa68b7571f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1mkdirReturn.html">mkdirReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#abf525d02b8c49f21ef7faa68b7571f93">mkdir</a> (std::string <a class="el" href="structJSL_1_1NameValuePair.html">directory</a>)</td></tr>
<tr class="separator:abf525d02b8c49f21ef7faa68b7571f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ff6f134180e7d98a22629381cedc1e" id="r_a28ff6f134180e7d98a22629381cedc1e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a28ff6f134180e7d98a22629381cedc1e">rgb_to_hsv</a> (std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt; <a class="el" href="structJSL_1_1NameValuePair.html">rgb</a>)</td></tr>
<tr class="separator:a28ff6f134180e7d98a22629381cedc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756feffb8dbaced50b21d33d25a416d6" id="r_a756feffb8dbaced50b21d33d25a416d6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a756feffb8dbaced50b21d33d25a416d6">hsv_to_rgb</a> (std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt; <a class="el" href="structJSL_1_1NameValuePair.html">hsv</a>)</td></tr>
<tr class="separator:a756feffb8dbaced50b21d33d25a416d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682c8bb3fff54370f38dcb16794fc7c5" id="r_a682c8bb3fff54370f38dcb16794fc7c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a682c8bb3fff54370f38dcb16794fc7c5">operator==</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:a682c8bb3fff54370f38dcb16794fc7c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">An overloaded equality checker. Checks size, then checks each entry - quick for finding mismatches, but requires full sweep to confirm total equality.  <br /></td></tr>
<tr class="separator:a682c8bb3fff54370f38dcb16794fc7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b19814a4b6cb667d1e27133acc38513" id="r_a8b19814a4b6cb667d1e27133acc38513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a8b19814a4b6cb667d1e27133acc38513">operator!=</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:a8b19814a4b6cb667d1e27133acc38513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply returns the inverse of the equality operator.  <br /></td></tr>
<tr class="separator:a8b19814a4b6cb667d1e27133acc38513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d1bbf23dc57ec028ea8d91a9688957" id="r_a38d1bbf23dc57ec028ea8d91a9688957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a38d1bbf23dc57ec028ea8d91a9688957">MatrixSizesEqual</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">m1</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">m2</a>)</td></tr>
<tr class="memdesc:a38d1bbf23dc57ec028ea8d91a9688957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Confirms the sizes (i.e. row count and column count) of the matrices are equal.  <br /></td></tr>
<tr class="separator:a38d1bbf23dc57ec028ea8d91a9688957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bcc74167579ecff71209bf8c9c47a3" id="r_ad1bcc74167579ecff71209bf8c9c47a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ad1bcc74167579ecff71209bf8c9c47a3">operator+</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:ad1bcc74167579ecff71209bf8c9c47a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs obvious matrix addition (a+b)_ij = a_ij + b_ij. Throws an error if the matrices are not the same size.  <br /></td></tr>
<tr class="separator:ad1bcc74167579ecff71209bf8c9c47a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1a2a224c7f6a8c57627b03594cd89f" id="r_a4f1a2a224c7f6a8c57627b03594cd89f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a4f1a2a224c7f6a8c57627b03594cd89f">operator-</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:a4f1a2a224c7f6a8c57627b03594cd89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs obvious matrix subtraction (a-b)_ij = a_ij - b_ij. Throws an error if the matrices are not the same size.  <br /></td></tr>
<tr class="separator:a4f1a2a224c7f6a8c57627b03594cd89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad779a68a2d565490f76dd16adfc3091e" id="r_ad779a68a2d565490f76dd16adfc3091e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ad779a68a2d565490f76dd16adfc3091e">operator+</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>)</td></tr>
<tr class="memdesc:ad779a68a2d565490f76dd16adfc3091e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the value of scalar to every element in the matrix.  <br /></td></tr>
<tr class="separator:ad779a68a2d565490f76dd16adfc3091e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d670e99aed43f857d8ba5e6f3d7897" id="r_a95d670e99aed43f857d8ba5e6f3d7897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a95d670e99aed43f857d8ba5e6f3d7897">operator*</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:a95d670e99aed43f857d8ba5e6f3d7897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs standard matix multiplication, (AB)_ij = A_ik B_kj. Only works on matrices of compatible sizes, and left-right ordering matters.  <br /></td></tr>
<tr class="separator:a95d670e99aed43f857d8ba5e6f3d7897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823f5e48d384320644698917c0a1c85c" id="r_a823f5e48d384320644698917c0a1c85c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a823f5e48d384320644698917c0a1c85c">operator*</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:a823f5e48d384320644698917c0a1c85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a vector by the matrix, following the rule (Av)_i = A_ij v_j.  <br /></td></tr>
<tr class="separator:a823f5e48d384320644698917c0a1c85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6c1988cf84b088617e0f12fc1e98da" id="r_a5f6c1988cf84b088617e0f12fc1e98da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a5f6c1988cf84b088617e0f12fc1e98da">operator+</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:a5f6c1988cf84b088617e0f12fc1e98da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exactly equivalent to <a class="el" href="namespaceJSL.html#ad779a68a2d565490f76dd16adfc3091e" title="Adds the value of scalar to every element in the matrix.">JSL::operator+(const Matrix &amp;lhs, const double &amp;scalar)</a>, just swapped around.  <br /></td></tr>
<tr class="separator:a5f6c1988cf84b088617e0f12fc1e98da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5304adbdadcb062246266f4ece24a1" id="r_a6d5304adbdadcb062246266f4ece24a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a6d5304adbdadcb062246266f4ece24a1">operator-</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>)</td></tr>
<tr class="memdesc:a6d5304adbdadcb062246266f4ece24a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the value of scalar to every element in the <a class="el" href="classJSL_1_1Matrix.html">Matrix</a>.  <br /></td></tr>
<tr class="separator:a6d5304adbdadcb062246266f4ece24a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fcd230a03dd81f1c37fec030619bf9" id="r_a80fcd230a03dd81f1c37fec030619bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a80fcd230a03dd81f1c37fec030619bf9">operator*</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:a80fcd230a03dd81f1c37fec030619bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Naive element-wise scalar multiplication.  <br /></td></tr>
<tr class="separator:a80fcd230a03dd81f1c37fec030619bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69548e09ba5835ee87ac4d28907b5435" id="r_a69548e09ba5835ee87ac4d28907b5435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a69548e09ba5835ee87ac4d28907b5435">operator*</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>)</td></tr>
<tr class="memdesc:a69548e09ba5835ee87ac4d28907b5435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of <a class="el" href="namespaceJSL.html#a5f6c1988cf84b088617e0f12fc1e98da" title="Exactly equivalent to JSL::operator+(const Matrix &amp;lhs, const double &amp;scalar), just swapped around.">JSL::operator+(const double &amp;scalar,const Matrix &amp;rhs)</a> with the operation order swapped around.  <br /></td></tr>
<tr class="separator:a69548e09ba5835ee87ac4d28907b5435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f3153179f59c59a0c2a5e553889eb1" id="r_ab1f3153179f59c59a0c2a5e553889eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ab1f3153179f59c59a0c2a5e553889eb1">operator/</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>)</td></tr>
<tr class="memdesc:ab1f3153179f59c59a0c2a5e553889eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Essentially an alias for <a class="el" href="namespaceJSL.html#a5f6c1988cf84b088617e0f12fc1e98da" title="Exactly equivalent to JSL::operator+(const Matrix &amp;lhs, const double &amp;scalar), just swapped around.">JSL::operator+(const double &amp;scalar,const Matrix &amp;rhs)</a> with the scalar set to one-over itself, i.e. pointwise division of the provided matrix.  <br /></td></tr>
<tr class="separator:ab1f3153179f59c59a0c2a5e553889eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebaffa5dc8073b816908a9708a36b7bf" id="r_aebaffa5dc8073b816908a9708a36b7bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#aebaffa5dc8073b816908a9708a36b7bf">operator-</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:aebaffa5dc8073b816908a9708a36b7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slightly odd operation (included for completeness) - adds the value of scalar to the negative of the elements of the vector.  <br /></td></tr>
<tr class="separator:aebaffa5dc8073b816908a9708a36b7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e357c34e91d1eb03c15ca437a285ea1" id="r_a7e357c34e91d1eb03c15ca437a285ea1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a7e357c34e91d1eb03c15ca437a285ea1">operator&lt;&lt;</a> (std::ostream &amp;<a class="el" href="structJSL_1_1NameValuePair.html">os</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">obj</a>)</td></tr>
<tr class="memdesc:a7e357c34e91d1eb03c15ca437a285ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="classJSL_1_1Matrix.html#abcf44559767ab6939851f0d3b60c6fa8" title="Converts the matrix to a human-readable string.">JSL::Matrix::to_string()</a> and then passes it to the provided stream, enabling sweet, smooth output such as std::cout &lt;&lt; M &lt;&lt; std::endl.  <br /></td></tr>
<tr class="separator:a7e357c34e91d1eb03c15ca437a285ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017f24cfdf73ecc218aab718c1badd89" id="r_a017f24cfdf73ecc218aab718c1badd89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a017f24cfdf73ecc218aab718c1badd89">FractionBounder</a> (<a class="el" href="structJSL_1_1NameValuePair.html">double</a> <a class="el" href="structJSL_1_1NameValuePair.html">a</a>)</td></tr>
<tr class="memdesc:a017f24cfdf73ecc218aab718c1badd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">A useful function when one knows a value needs to be between 0 and 1.  <br /></td></tr>
<tr class="separator:a017f24cfdf73ecc218aab718c1badd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae64b7e0cfdc1ab5f35cca90c32d9f6" id="r_aeae64b7e0cfdc1ab5f35cca90c32d9f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#aeae64b7e0cfdc1ab5f35cca90c32d9f6">VectorDotProduct</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:aeae64b7e0cfdc1ab5f35cca90c32d9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard dot product on R^n.  <br /></td></tr>
<tr class="separator:aeae64b7e0cfdc1ab5f35cca90c32d9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7816eb0cd81b74241ce460237990e70" id="r_aa7816eb0cd81b74241ce460237990e70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#aa7816eb0cd81b74241ce460237990e70">VectorCrossProduct</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:aa7816eb0cd81b74241ce460237990e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard cross product &ndash; only defined on R^3 (throws an error else)  <br /></td></tr>
<tr class="separator:aa7816eb0cd81b74241ce460237990e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09355c91f84fd99d4634bf9189fef51d" id="r_a09355c91f84fd99d4634bf9189fef51d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a09355c91f84fd99d4634bf9189fef51d">AngleBetweenVectors</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:a09355c91f84fd99d4634bf9189fef51d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses <a class="el" href="classJSL_1_1Vector.html#aa8af717591f5548ff471b6e4b28d7f9c" title="The norm of the current object,.">Vector::Norm()</a> and <a class="el" href="namespaceJSL.html#aeae64b7e0cfdc1ab5f35cca90c32d9f6" title="The standard dot product on R^n.">VectorDotProduct()</a> to extract an angle between the vectors.  <br /></td></tr>
<tr class="separator:a09355c91f84fd99d4634bf9189fef51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fad54be308ccb76f68933d91c3c542f" id="r_a7fad54be308ccb76f68933d91c3c542f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a7fad54be308ccb76f68933d91c3c542f">operator==</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="separator:a7fad54be308ccb76f68933d91c3c542f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394a4f9cee0747c76d1190b0365c7b5a" id="r_a394a4f9cee0747c76d1190b0365c7b5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a394a4f9cee0747c76d1190b0365c7b5a">operator!=</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="separator:a394a4f9cee0747c76d1190b0365c7b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6530b77174d0dfae8e0d6e2a810f672" id="r_ae6530b77174d0dfae8e0d6e2a810f672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ae6530b77174d0dfae8e0d6e2a810f672">operator+</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:ae6530b77174d0dfae8e0d6e2a810f672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs obvious vector addition (a+b)_i = a_i + b_i. Throws an error if the vectors are not the same size.  <br /></td></tr>
<tr class="separator:ae6530b77174d0dfae8e0d6e2a810f672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8393f2865dc23e7975ad041e341ba5" id="r_a1d8393f2865dc23e7975ad041e341ba5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a1d8393f2865dc23e7975ad041e341ba5">operator-</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:a1d8393f2865dc23e7975ad041e341ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs obvious vector subtraction (a-b)_i = a_i - b_i. Throws an error if the vectors are not the same size.  <br /></td></tr>
<tr class="separator:a1d8393f2865dc23e7975ad041e341ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b293e2ac3df51113e80022cb3c2ac99" id="r_a4b293e2ac3df51113e80022cb3c2ac99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a4b293e2ac3df51113e80022cb3c2ac99">operator+</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>)</td></tr>
<tr class="memdesc:a4b293e2ac3df51113e80022cb3c2ac99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the value of scalar to every element in the vector.  <br /></td></tr>
<tr class="separator:a4b293e2ac3df51113e80022cb3c2ac99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ceabb8b9e657c5e2d0faf9b20a36e8" id="r_ac5ceabb8b9e657c5e2d0faf9b20a36e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ac5ceabb8b9e657c5e2d0faf9b20a36e8">operator+</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:ac5ceabb8b9e657c5e2d0faf9b20a36e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exactly equivalent to <a class="el" href="namespaceJSL.html#a4b293e2ac3df51113e80022cb3c2ac99" title="Adds the value of scalar to every element in the vector.">JSL::operator+(const Vector &amp;lhs, const double &amp;scalar)</a>, just swapped around.  <br /></td></tr>
<tr class="separator:ac5ceabb8b9e657c5e2d0faf9b20a36e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bd9311dd73aa6227d826bdb94e748d" id="r_ac6bd9311dd73aa6227d826bdb94e748d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ac6bd9311dd73aa6227d826bdb94e748d">operator-</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>)</td></tr>
<tr class="memdesc:ac6bd9311dd73aa6227d826bdb94e748d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts the value of scalar to every element in the vector.  <br /></td></tr>
<tr class="separator:ac6bd9311dd73aa6227d826bdb94e748d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d17c5cc03a2048e8637d2054fbc138" id="r_ab3d17c5cc03a2048e8637d2054fbc138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ab3d17c5cc03a2048e8637d2054fbc138">operator-</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:ab3d17c5cc03a2048e8637d2054fbc138"><td class="mdescLeft">&#160;</td><td class="mdescRight">A slightly odd operation (included for completeness) - adds the value of scalar to the negative of the elements of the vector.  <br /></td></tr>
<tr class="separator:ab3d17c5cc03a2048e8637d2054fbc138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4eefbed468f275164855895335b8a29" id="r_ab4eefbed468f275164855895335b8a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ab4eefbed468f275164855895335b8a29">operator*</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:ab4eefbed468f275164855895335b8a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Naive element-wise scalar multiplication.  <br /></td></tr>
<tr class="separator:ab4eefbed468f275164855895335b8a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5e092de4a9bdc5795d40ee0f51c7b9" id="r_afc5e092de4a9bdc5795d40ee0f51c7b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#afc5e092de4a9bdc5795d40ee0f51c7b9">operator*</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>)</td></tr>
<tr class="memdesc:afc5e092de4a9bdc5795d40ee0f51c7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias of <a class="el" href="namespaceJSL.html#ac5ceabb8b9e657c5e2d0faf9b20a36e8" title="Exactly equivalent to JSL::operator+(const Vector &amp;lhs, const double &amp;scalar), just swapped around.">JSL::operator+(const double &amp;scalar,const Vector &amp;rhs)</a> with the operation order swapped around.  <br /></td></tr>
<tr class="separator:afc5e092de4a9bdc5795d40ee0f51c7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1427fd44260592b7d65d27946969fba1" id="r_a1427fd44260592b7d65d27946969fba1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a1427fd44260592b7d65d27946969fba1">operator/</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">scalar</a>)</td></tr>
<tr class="memdesc:a1427fd44260592b7d65d27946969fba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Essentially an alias for <a class="el" href="namespaceJSL.html#ac5ceabb8b9e657c5e2d0faf9b20a36e8" title="Exactly equivalent to JSL::operator+(const Vector &amp;lhs, const double &amp;scalar), just swapped around.">JSL::operator+(const double &amp;scalar,const Vector &amp;rhs)</a> with the scalar set to one-over itself, i.e. pointwise division of the provided vector.  <br /></td></tr>
<tr class="separator:a1427fd44260592b7d65d27946969fba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd4487b0a8ac5713df4a37079287913" id="r_a6fd4487b0a8ac5713df4a37079287913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a6fd4487b0a8ac5713df4a37079287913">Hadamard</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">lhs</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">rhs</a>)</td></tr>
<tr class="memdesc:a6fd4487b0a8ac5713df4a37079287913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the pointwise (Hadamard) product of two vectors.  <br /></td></tr>
<tr class="separator:a6fd4487b0a8ac5713df4a37079287913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01cc2984ad2ce5a85fb31960835dd04" id="r_ad01cc2984ad2ce5a85fb31960835dd04"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ad01cc2984ad2ce5a85fb31960835dd04">operator&lt;&lt;</a> (std::ostream &amp;<a class="el" href="structJSL_1_1NameValuePair.html">os</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">obj</a>)</td></tr>
<tr class="memdesc:ad01cc2984ad2ce5a85fb31960835dd04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="classJSL_1_1Vector.html#a73579b4a194cc924341806a5d9ea3817" title="Converts the vector into a human-readable string.">JSL::Vector::to_string()</a> and then passes it to the provided stream, enabling sweet, smooth output such as std::cout &lt;&lt; v1 &lt;&lt; std::endl.  <br /></td></tr>
<tr class="separator:ad01cc2984ad2ce5a85fb31960835dd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941b0093a8d1298a0dc0c4403f63a826" id="r_a941b0093a8d1298a0dc0c4403f63a826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a941b0093a8d1298a0dc0c4403f63a826">ElementWiseOperation</a> (<a class="el" href="classJSL_1_1Vector.html">Vector</a> <a class="el" href="structJSL_1_1NameValuePair.html">input</a>, <a class="el" href="structJSL_1_1NameValuePair.html">double</a>(*<a class="el" href="structJSL_1_1NameValuePair.html">function</a>)(<a class="el" href="structJSL_1_1NameValuePair.html">double</a>))</td></tr>
<tr class="memdesc:a941b0093a8d1298a0dc0c4403f63a826"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nice way to perform a simple function on every element of a vector.  <br /></td></tr>
<tr class="separator:a941b0093a8d1298a0dc0c4403f63a826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d56be27b8b9b13e6ab8a3c61236ee3" id="r_a84d56be27b8b9b13e6ab8a3c61236ee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a84d56be27b8b9b13e6ab8a3c61236ee3">log10</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">input</a>)</td></tr>
<tr class="separator:a84d56be27b8b9b13e6ab8a3c61236ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c1c8f6c27fe101b0731477de5535b7" id="r_a66c1c8f6c27fe101b0731477de5535b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a66c1c8f6c27fe101b0731477de5535b7">power</a> (<a class="el" href="structJSL_1_1NameValuePair.html">double</a> <a class="el" href="structJSL_1_1NameValuePair.html">base</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;<a class="el" href="structJSL_1_1NameValuePair.html">exponent</a>)</td></tr>
<tr class="separator:a66c1c8f6c27fe101b0731477de5535b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37a5ffd99a34e2f12377c9f00b31c50" id="r_aa37a5ffd99a34e2f12377c9f00b31c50"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#aa37a5ffd99a34e2f12377c9f00b31c50">split</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">s</a>, <a class="el" href="structJSL_1_1NameValuePair.html">char</a> <a class="el" href="structJSL_1_1NameValuePair.html">delimiter</a>)</td></tr>
<tr class="separator:aa37a5ffd99a34e2f12377c9f00b31c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58b7096986a16b70a27e1609eff3014" id="r_ae58b7096986a16b70a27e1609eff3014"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ae58b7096986a16b70a27e1609eff3014">CurrentTime</a> ()</td></tr>
<tr class="separator:ae58b7096986a16b70a27e1609eff3014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ff2220bbab0294b95b9aa85332a222" id="r_ad7ff2220bbab0294b95b9aa85332a222"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ad7ff2220bbab0294b95b9aa85332a222">FormatDuration</a> (<a class="el" href="structJSL_1_1NameValuePair.html">int</a> <a class="el" href="structJSL_1_1NameValuePair.html">timeInSeconds</a>)</td></tr>
<tr class="separator:ad7ff2220bbab0294b95b9aa85332a222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7af96a0311784e019209221335f76d9" id="r_ae7af96a0311784e019209221335f76d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ae7af96a0311784e019209221335f76d9">FormatClock</a> (std::chrono::time_point&lt; std::chrono::system_clock &gt; <a class="el" href="structJSL_1_1NameValuePair.html">start</a>, std::chrono::time_point&lt; std::chrono::system_clock &gt; <a class="el" href="structJSL_1_1NameValuePair.html">end</a>)</td></tr>
<tr class="separator:ae7af96a0311784e019209221335f76d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7afe30fd764dc4151982a2631f08d3" id="r_a1a7afe30fd764dc4151982a2631f08d3"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a1a7afe30fd764dc4151982a2631f08d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a1a7afe30fd764dc4151982a2631f08d3">Assert</a> (std::string <a class="el" href="structJSL_1_1NameValuePair.html">assertionMessage</a>, Ts... <a class="el" href="structJSL_1_1NameValuePair.html">args</a>)</td></tr>
<tr class="separator:a1a7afe30fd764dc4151982a2631f08d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5783bc90550deca94c1790e581fb707d" id="r_a5783bc90550deca94c1790e581fb707d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a5783bc90550deca94c1790e581fb707d">Error</a> (<a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61">ErrorCode</a> <a class="el" href="structJSL_1_1NameValuePair.html">code</a>, <a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">message</a>)</td></tr>
<tr class="separator:a5783bc90550deca94c1790e581fb707d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0241a3cc1fa4dd4d319ab8686d1cfaa3" id="r_a0241a3cc1fa4dd4d319ab8686d1cfaa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a0241a3cc1fa4dd4d319ab8686d1cfaa3">Error</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">message</a>)</td></tr>
<tr class="memdesc:a0241a3cc1fa4dd4d319ab8686d1cfaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default version of <a class="el" href="namespaceJSL.html#a5783bc90550deca94c1790e581fb707d">Error(ErrorCode code, const std::string &amp; message)</a>, throwing <a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61a0a229ef32833c9a64ed38080ba87b196" title="Global error term.">JSL::JSLError</a> as the identifier code.  <br /></td></tr>
<tr class="separator:a0241a3cc1fa4dd4d319ab8686d1cfaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbf4a35e1d5a856d7c301e1e5829c2f" id="r_addbf4a35e1d5a856d7c301e1e5829c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#addbf4a35e1d5a856d7c301e1e5829c2f">PipedInputFound</a> ()</td></tr>
<tr class="memdesc:addbf4a35e1d5a856d7c301e1e5829c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for an isatty command, given a easier to remember name.  <br /></td></tr>
<tr class="separator:addbf4a35e1d5a856d7c301e1e5829c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54b96d9c3678069d34aa56f4a3b3a0f" id="r_ac54b96d9c3678069d34aa56f4a3b3a0f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ac54b96d9c3678069d34aa56f4a3b3a0f">readPipedInputString</a> ()</td></tr>
<tr class="memdesc:ac54b96d9c3678069d34aa56f4a3b3a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the most basic readin --&gt; saves the piped input to a string, and returns it.  <br /></td></tr>
<tr class="separator:ac54b96d9c3678069d34aa56f4a3b3a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48b92e64fb9d321121df976b770efa6" id="r_ae48b92e64fb9d321121df976b770efa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#ae48b92e64fb9d321121df976b770efa6">rm</a> (std::string <a class="el" href="structJSL_1_1NameValuePair.html">location</a>, <a class="el" href="structJSL_1_1NameValuePair.html">bool</a> <a class="el" href="structJSL_1_1NameValuePair.html">recursive</a>)</td></tr>
<tr class="separator:ae48b92e64fb9d321121df976b770efa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd4ed117decf1140104ad8566b589ac" id="r_a5cd4ed117decf1140104ad8566b589ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a5cd4ed117decf1140104ad8566b589ac">systemCall</a> (<a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;<a class="el" href="structJSL_1_1NameValuePair.html">command</a>)</td></tr>
<tr class="memdesc:a5cd4ed117decf1140104ad8566b589ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses C++'s std::system to run a command given by the inpt string, and checks for errors.  <br /></td></tr>
<tr class="separator:a5cd4ed117decf1140104ad8566b589ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2822caa026c439b483c262bb5edf30aa" id="r_a2822caa026c439b483c262bb5edf30aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a2822caa026c439b483c262bb5edf30aa">DEFAULT_TOGGLE_VALUE</a> = <a class="el" href="structJSL_1_1NameValuePair.html">false</a></td></tr>
<tr class="separator:a2822caa026c439b483c262bb5edf30aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606f5a286ccd4cf3d860d2efde2eac82" id="r_a606f5a286ccd4cf3d860d2efde2eac82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceJSL.html#a606f5a286ccd4cf3d860d2efde2eac82">ErrorNames</a> = {&quot;ERROR&quot;, &quot;SYSTEM <a class="el" href="structJSL_1_1NameValuePair.html">ERROR&quot;</a>, &quot;OVERRUN <a class="el" href="structJSL_1_1NameValuePair.html">ERROR&quot;</a>, &quot;FAILED <a class="el" href="structJSL_1_1NameValuePair.html">ASSERTION&quot;</a>,&quot;IOError&quot;, &quot;GNUPLOT <a class="el" href="structJSL_1_1NameValuePair.html">ERROR&quot;</a>}</td></tr>
<tr class="separator:a606f5a286ccd4cf3d860d2efde2eac82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5059dbafa288b9b3beac1746f4acae61" name="a5059dbafa288b9b3beac1746f4acae61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5059dbafa288b9b3beac1746f4acae61">&#9670;&#160;</a></span>ErrorCode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">enum</a> <a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61">JSL::ErrorCode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of recognised <a class="el" href="namespaceJSL.html">JSL</a> errors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5059dbafa288b9b3beac1746f4acae61a0a229ef32833c9a64ed38080ba87b196" name="a5059dbafa288b9b3beac1746f4acae61a0a229ef32833c9a64ed38080ba87b196"></a>JSLError&#160;</td><td class="fielddoc"><p>Global error term. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5059dbafa288b9b3beac1746f4acae61ab2e398994d8ffbb8c17109c9ec85ed30" name="a5059dbafa288b9b3beac1746f4acae61ab2e398994d8ffbb8c17109c9ec85ed30"></a>SystemError&#160;</td><td class="fielddoc"><p>Used when something really went bad, like a failed <a class="el" href="namespaceJSL.html#a5cd4ed117decf1140104ad8566b589ac" title="Uses C++&#39;s std::system to run a command given by the inpt string, and checks for errors.">JSL::systemCall</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5059dbafa288b9b3beac1746f4acae61afec2ceb4545826a8594a9dc7a7b1c702" name="a5059dbafa288b9b3beac1746f4acae61afec2ceb4545826a8594a9dc7a7b1c702"></a>OverrunError&#160;</td><td class="fielddoc"><p><a class="el" href="classJSL_1_1Vector.html">Vector</a> Access overruns, bad memory requests. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5059dbafa288b9b3beac1746f4acae61a007fec64442c721c18380cb70c51a443" name="a5059dbafa288b9b3beac1746f4acae61a007fec64442c721c18380cb70c51a443"></a>FailedAssertion&#160;</td><td class="fielddoc"><p>As the name implies, failed assertions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5059dbafa288b9b3beac1746f4acae61a7da39e712d8960d161fbef3305d793a4" name="a5059dbafa288b9b3beac1746f4acae61a7da39e712d8960d161fbef3305d793a4"></a>IOError&#160;</td><td class="fielddoc"><p>Errors induced by file. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5059dbafa288b9b3beac1746f4acae61ae87e52367d118ac8a793c78a53ec9973" name="a5059dbafa288b9b3beac1746f4acae61ae87e52367d118ac8a793c78a53ec9973"></a>PlottingError&#160;</td><td class="fielddoc"><p>Unique error induced by <a class="el" href="classJSL_1_1gnuplot.html" title="The global interface for the plotting system. All calls should be piped through this individual class...">JSL::gnuplot</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="acbabfae0b320d418d49485b7c50bc355" name="acbabfae0b320d418d49485b7c50bc355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbabfae0b320d418d49485b7c50bc355">&#9670;&#160;</a></span>LineType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">enum</a> <a class="el" href="namespaceJSL.html#acbabfae0b320d418d49485b7c50bc355">JSL::LineType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acbabfae0b320d418d49485b7c50bc355aaf6d64d28f76aa54961a419d3d9e17b5" name="acbabfae0b320d418d49485b7c50bc355aaf6d64d28f76aa54961a419d3d9e17b5"></a>Solid&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acbabfae0b320d418d49485b7c50bc355a5d77703e9d097677886b897d9a2eeb62" name="acbabfae0b320d418d49485b7c50bc355a5d77703e9d097677886b897d9a2eeb62"></a>Dash&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acbabfae0b320d418d49485b7c50bc355af0b887cb0d75c330317bc843146bfc92" name="acbabfae0b320d418d49485b7c50bc355af0b887cb0d75c330317bc843146bfc92"></a>DashDot&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acbabfae0b320d418d49485b7c50bc355ac3cd9b153ce73b7d8dd0485ae186379d" name="acbabfae0b320d418d49485b7c50bc355ac3cd9b153ce73b7d8dd0485ae186379d"></a>Dotted&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acbabfae0b320d418d49485b7c50bc355a48afd9609abb3d990c826b2c74850d3e" name="acbabfae0b320d418d49485b7c50bc355a48afd9609abb3d990c826b2c74850d3e"></a>DashDotDot&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a871354b683a8bee0151dbfbbde49beda" name="a871354b683a8bee0151dbfbbde49beda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871354b683a8bee0151dbfbbde49beda">&#9670;&#160;</a></span>PlotType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">enum</a> <a class="el" href="namespaceJSL.html#a871354b683a8bee0151dbfbbde49beda">JSL::PlotType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a871354b683a8bee0151dbfbbde49bedaafa1098e16302d619cc16c6117128c7e2" name="a871354b683a8bee0151dbfbbde49bedaafa1098e16302d619cc16c6117128c7e2"></a>Line&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a871354b683a8bee0151dbfbbde49bedaa523747d04b06019ae6db545703793d22" name="a871354b683a8bee0151dbfbbde49bedaa523747d04b06019ae6db545703793d22"></a>ScatterPoint&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a871354b683a8bee0151dbfbbde49bedaa18063242b9bed054d8672dd4efb6cd33" name="a871354b683a8bee0151dbfbbde49bedaa18063242b9bed054d8672dd4efb6cd33"></a>BarChart&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a871354b683a8bee0151dbfbbde49bedaa5411aeb3b0211480c96c5d14e5e41e53" name="a871354b683a8bee0151dbfbbde49bedaa5411aeb3b0211480c96c5d14e5e41e53"></a>SurfaceMap&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad5aeae8cb562d6f38c724cbdc51d81f8" name="ad5aeae8cb562d6f38c724cbdc51d81f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5aeae8cb562d6f38c724cbdc51d81f8">&#9670;&#160;</a></span>Property</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">enum</a> <a class="el" href="namespaceJSL.html#ad5aeae8cb562d6f38c724cbdc51d81f8">JSL::Property</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad5aeae8cb562d6f38c724cbdc51d81f8ae7660181e67b34cc8012e44899358c0a" name="ad5aeae8cb562d6f38c724cbdc51d81f8ae7660181e67b34cc8012e44899358c0a"></a>Colour&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad5aeae8cb562d6f38c724cbdc51d81f8a22d189b48d50314bdd20b34e9a40e4a5" name="ad5aeae8cb562d6f38c724cbdc51d81f8a22d189b48d50314bdd20b34e9a40e4a5"></a>PenSize&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad5aeae8cb562d6f38c724cbdc51d81f8ab516e098813c27967b8e649b94f98db8" name="ad5aeae8cb562d6f38c724cbdc51d81f8ab516e098813c27967b8e649b94f98db8"></a>PenType&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad5aeae8cb562d6f38c724cbdc51d81f8afadeba2e8b035dc3c761f416c88a293d" name="ad5aeae8cb562d6f38c724cbdc51d81f8afadeba2e8b035dc3c761f416c88a293d"></a>Legend&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a086efb36ddb107d45961a6b46932c526" name="a086efb36ddb107d45961a6b46932c526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086efb36ddb107d45961a6b46932c526">&#9670;&#160;</a></span>ScatterType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">enum</a> <a class="el" href="namespaceJSL.html#a086efb36ddb107d45961a6b46932c526">JSL::ScatterType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526a7d6491e51b0151fad51114bdc9fe0006" name="a086efb36ddb107d45961a6b46932c526a7d6491e51b0151fad51114bdc9fe0006"></a>Dot&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526ac54fadde63eae4fbfb5090af9e2c8c68" name="a086efb36ddb107d45961a6b46932c526ac54fadde63eae4fbfb5090af9e2c8c68"></a>Plus&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526af2349f50039f930d90a39a689282aaf8" name="a086efb36ddb107d45961a6b46932c526af2349f50039f930d90a39a689282aaf8"></a>Cross&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526a3d4283b7785e19142f43a8d705f45128" name="a086efb36ddb107d45961a6b46932c526a3d4283b7785e19142f43a8d705f45128"></a>Star&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526af5af415948dea41c775febe11df59707" name="a086efb36ddb107d45961a6b46932c526af5af415948dea41c775febe11df59707"></a>OpenSquare&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526ab2977a42bdf7f8cafd62d56eb573d71a" name="a086efb36ddb107d45961a6b46932c526ab2977a42bdf7f8cafd62d56eb573d71a"></a>FilledSquare&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526a24102e043f642c5aadf0a5184838e065" name="a086efb36ddb107d45961a6b46932c526a24102e043f642c5aadf0a5184838e065"></a>OpenCircle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526a1e5a2218783d5197e73aab6b16f3add3" name="a086efb36ddb107d45961a6b46932c526a1e5a2218783d5197e73aab6b16f3add3"></a>FilledCircle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526a163fb60ab5d5beca95d7afa4c97d6fda" name="a086efb36ddb107d45961a6b46932c526a163fb60ab5d5beca95d7afa4c97d6fda"></a>OpenDelta&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526abc2204e7d338e5c0f3c5b524c3250352" name="a086efb36ddb107d45961a6b46932c526abc2204e7d338e5c0f3c5b524c3250352"></a>FilledDelta&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526ae6f313a61f49260feabbe0252daebf39" name="a086efb36ddb107d45961a6b46932c526ae6f313a61f49260feabbe0252daebf39"></a>OpenNabla&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526ac57738c0de5dcd2b52aedd0ac353fcd8" name="a086efb36ddb107d45961a6b46932c526ac57738c0de5dcd2b52aedd0ac353fcd8"></a>FilledNabla&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526aede7da49ec9867bc58a9883ac6f7fd12" name="a086efb36ddb107d45961a6b46932c526aede7da49ec9867bc58a9883ac6f7fd12"></a>OpenDiamond&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a086efb36ddb107d45961a6b46932c526a9ba302e97b23281952e4e194387808b2" name="a086efb36ddb107d45961a6b46932c526a9ba302e97b23281952e4e194387808b2"></a>FilledDiamond&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a09355c91f84fd99d4634bf9189fef51d" name="a09355c91f84fd99d4634bf9189fef51d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09355c91f84fd99d4634bf9189fef51d">&#9670;&#160;</a></span>AngleBetweenVectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">double</a> JSL::AngleBetweenVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses <a class="el" href="classJSL_1_1Vector.html#aa8af717591f5548ff471b6e4b28d7f9c" title="The norm of the current object,.">Vector::Norm()</a> and <a class="el" href="namespaceJSL.html#aeae64b7e0cfdc1ab5f35cca90c32d9f6" title="The standard dot product on R^n.">VectorDotProduct()</a> to extract an angle between the vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td><a class="el" href="classJSL_1_1Vector.html">Vector</a> 1,</td></tr>
    <tr><td class="paramname">rhs</td><td><a class="el" href="classJSL_1_1Vector.html">Vector</a> 2 (order irrelevant) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle between the two vectors (between 0 and M_PI) </dd></dl>

</div>
</div>
<a id="a1a7afe30fd764dc4151982a2631f08d3" name="a1a7afe30fd764dc4151982a2631f08d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7afe30fd764dc4151982a2631f08d3">&#9670;&#160;</a></span>Assert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::Assert </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>assertionMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function which checks that a stated set of conditions are met, and throws a <a class="el" href="namespaceJSL.html#a5783bc90550deca94c1790e581fb707d">JSL::Error</a> if they are not. Variadic function, and so accepts an arbitrary number of conditions without impact on runtime.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assertionMessage</td><td>The message that gets printed out if the assertion fails. Also useful for internal documentation of code</td></tr>
    <tr><td class="paramname">args</td><td>A list of booleans to be checked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a071b279ad5267ce66ff86c614952a3ed" name="a071b279ad5267ce66ff86c614952a3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071b279ad5267ce66ff86c614952a3ed">&#9670;&#160;</a></span>clearScreen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::clearScreen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equivalent to calling the "clear" command on the shell, removes all text on the terminal, and returns the cursor to the home position. </p>

</div>
</div>
<a id="ae58b7096986a16b70a27e1609eff3014" name="ae58b7096986a16b70a27e1609eff3014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58b7096986a16b70a27e1609eff3014">&#9670;&#160;</a></span>CurrentTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string JSL::CurrentTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get current system time in a readable format (note: was previously called PrintCurrentTime) </p><dl class="section return"><dt>Returns</dt><dd>A string of the readable format <br  />
 </dd></dl>

</div>
</div>
<a id="ae38780f94d60045b904b289eb3ab8eda" name="ae38780f94d60045b904b289eb3ab8eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38780f94d60045b904b289eb3ab8eda">&#9670;&#160;</a></span>deleteLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::deleteLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the last line of text, moving the cursor from its current position, to the beginning of the line. If you want to remove the linebreak which caused that line to exist in the first place, must be followed up with <a class="el" href="namespaceJSL.html#a405f53748ca024b70694b0534cfcf4a3" title="Deletes the last linebreak character, jumping the cursor up one line.">jumpLineUp()</a>. ALternatively, if a linebreak has been printed and you want to delete that line <em>first</em>, you must call <a class="el" href="namespaceJSL.html#a405f53748ca024b70694b0534cfcf4a3" title="Deletes the last linebreak character, jumping the cursor up one line.">jumpLineUp()</a> before <a class="el" href="namespaceJSL.html#ae38780f94d60045b904b289eb3ab8eda" title="Removes the last line of text, moving the cursor from its current position, to the beginning of the l...">deleteLine()</a>. </p>

</div>
</div>
<a id="a941b0093a8d1298a0dc0c4403f63a826" name="a941b0093a8d1298a0dc0c4403f63a826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941b0093a8d1298a0dc0c4403f63a826">&#9670;&#160;</a></span>ElementWiseOperation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> JSL::ElementWiseOperation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJSL_1_1Vector.html">Vector</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">double</a>(*)(<a class="el" href="structJSL_1_1NameValuePair.html">double</a>)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A nice way to perform a simple function on every element of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the vector on which the operation will be performed</td></tr>
    <tr><td class="paramname">function</td><td>A pointer to a funciton which accepts and returns a double. Can also be a lambda function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector y such that y_i = f(x_i) </dd></dl>

</div>
</div>
<a id="a0241a3cc1fa4dd4d319ab8686d1cfaa3" name="a0241a3cc1fa4dd4d319ab8686d1cfaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0241a3cc1fa4dd4d319ab8686d1cfaa3">&#9670;&#160;</a></span>Error() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::Error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default version of <a class="el" href="namespaceJSL.html#a5783bc90550deca94c1790e581fb707d">Error(ErrorCode code, const std::string &amp; message)</a>, throwing <a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61a0a229ef32833c9a64ed38080ba87b196" title="Global error term.">JSL::JSLError</a> as the identifier code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The error message passed to the throw command. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5783bc90550deca94c1790e581fb707d" name="a5783bc90550deca94c1790e581fb707d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5783bc90550deca94c1790e581fb707d">&#9670;&#160;</a></span>Error() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::Error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61">ErrorCode</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An easy way to package throwing errors using the throw command.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>One of <a class="el" href="namespaceJSL.html#a5059dbafa288b9b3beac1746f4acae61" title="A list of recognised JSL errors.">JSL::ErrorCode</a> to help identify the cause</td></tr>
    <tr><td class="paramname">message</td><td>The output message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab806e537ccfdea16b7d194d77cdb307e" name="ab806e537ccfdea16b7d194d77cdb307e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab806e537ccfdea16b7d194d77cdb307e">&#9670;&#160;</a></span>FindXInY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">int</a> JSL::FindXInY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">double</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets first id such that (y[id]- x)/x &lt; tolerance. If no such id exists, returns negative value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to be searched for</td></tr>
    <tr><td class="paramname">y</td><td>The vector to search through</td></tr>
    <tr><td class="paramname">tolerance</td><td>The fractional difference permitted between two double values for them to be declared "approximately equal" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first element in the array which matches x. Value is negative if no match found </dd></dl>

</div>
</div>
<a id="a428e6ac7fa22e5c5aa3bceb9e17fe970" name="a428e6ac7fa22e5c5aa3bceb9e17fe970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428e6ac7fa22e5c5aa3bceb9e17fe970">&#9670;&#160;</a></span>FindXInY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">int</a> JSL::FindXInY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">T</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets first id such that y[id] == x, assuming that exact equality is well defined (see double override). If no such id exists, returns negative value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to be searched for</td></tr>
    <tr><td class="paramname">y</td><td>The vector to search through </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first element in the array which matches x. Value is negative if no match found </dd></dl>

</div>
</div>
<a id="ae7af96a0311784e019209221335f76d9" name="ae7af96a0311784e019209221335f76d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7af96a0311784e019209221335f76d9">&#9670;&#160;</a></span>FormatClock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string JSL::FormatClock </td>
          <td>(</td>
          <td class="paramtype">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; std::chrono::system_clock &gt;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls <a class="el" href="namespaceJSL.html#ad7ff2220bbab0294b95b9aa85332a222">FormatDuration()</a> on the duration of the start and endpoints of a <code>chrono</code> stopwatch. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>A <code>chrono</code> object representing the start of the duration </td></tr>
    <tr><td class="paramname">end</td><td>The corresponding end-point <code>chrono</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7ff2220bbab0294b95b9aa85332a222" name="ad7ff2220bbab0294b95b9aa85332a222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ff2220bbab0294b95b9aa85332a222">&#9670;&#160;</a></span>FormatDuration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string JSL::FormatDuration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">int</a>&#160;</td>
          <td class="paramname"><em>timeInSeconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a duration in seconds, convert it into standard Day/Hour/Minute/Second formatted string. Times less than 1 second are reported as "less than 1 second" </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeInSeconds</td><td>The time to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A human-readable string equal to the input </dd></dl>

</div>
</div>
<a id="a017f24cfdf73ecc218aab718c1badd89" name="a017f24cfdf73ecc218aab718c1badd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017f24cfdf73ecc218aab718c1badd89">&#9670;&#160;</a></span>FractionBounder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">double</a> JSL::FractionBounder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">double</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A useful function when one knows a value needs to be between 0 and 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The value to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min(max(0,a),1), i.e., if 0 </dd></dl>

</div>
</div>
<a id="a6fd4487b0a8ac5713df4a37079287913" name="a6fd4487b0a8ac5713df4a37079287913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd4487b0a8ac5713df4a37079287913">&#9670;&#160;</a></span>Hadamard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> JSL::Hadamard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the pointwise (Hadamard) product of two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first vector to be multiplied</td></tr>
    <tr><td class="paramname">rhs</td><td>The second vector to be multiplied (order is irrelevant) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector (lhs * rhs)_i = lhs_i * rhs_i </dd></dl>

</div>
</div>
<a id="a756feffb8dbaced50b21d33d25a416d6" name="a756feffb8dbaced50b21d33d25a416d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756feffb8dbaced50b21d33d25a416d6">&#9670;&#160;</a></span>hsv_to_rgb()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt; JSL::hsv_to_rgb </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt;&#160;</td>
          <td class="paramname"><em>hsv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47d8cb112d513ee5a3ae38ca6a89743d" name="a47d8cb112d513ee5a3ae38ca6a89743d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d8cb112d513ee5a3ae38ca6a89743d">&#9670;&#160;</a></span>initialiseFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::initialiseFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a blank file at the specified location, overwriting any other file at the given location </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file which the system will attempt to open </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7885f51066f38fb013d8065b97a3013d" name="a7885f51066f38fb013d8065b97a3013d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7885f51066f38fb013d8065b97a3013d">&#9670;&#160;</a></span>jfglatex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::jfglatex </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>compilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td>
          <td class="paramname"><em>openfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td>
          <td class="paramname"><em>quietmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a405f53748ca024b70694b0534cfcf4a3" name="a405f53748ca024b70694b0534cfcf4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405f53748ca024b70694b0534cfcf4a3">&#9670;&#160;</a></span>jumpLineUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::jumpLineUp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes the last linebreak character, jumping the cursor up one line. </p>

</div>
</div>
<a id="aed873f557a849265f2197aa7a98d0da4" name="aed873f557a849265f2197aa7a98d0da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed873f557a849265f2197aa7a98d0da4">&#9670;&#160;</a></span>LineCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">int</a> JSL::LineCount </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1752cd7c6e1134da51e9307527e0d788" name="a1752cd7c6e1134da51e9307527e0d788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1752cd7c6e1134da51e9307527e0d788">&#9670;&#160;</a></span>locationExists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a> JSL::locationExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks for the existence of the provided file location, works on both files and directories. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the name of the file or directory to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if location exists (and is accessible), false if not </dd></dl>

</div>
</div>
<a id="a84d56be27b8b9b13e6ab8a3c61236ee3" name="a84d56be27b8b9b13e6ab8a3c61236ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d56be27b8b9b13e6ab8a3c61236ee3">&#9670;&#160;</a></span>log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> JSL::log10 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a38d1bbf23dc57ec028ea8d91a9688957" name="a38d1bbf23dc57ec028ea8d91a9688957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d1bbf23dc57ec028ea8d91a9688957">&#9670;&#160;</a></span>MatrixSizesEqual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a> JSL::MatrixSizesEqual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Confirms the sizes (i.e. row count and column count) of the matrices are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first matrix</td></tr>
    <tr><td class="paramname">rhs</td><td>the value to be compared to lhs for size equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if equal in size, false if not </dd></dl>

</div>
</div>
<a id="abf525d02b8c49f21ef7faa68b7571f93" name="abf525d02b8c49f21ef7faa68b7571f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf525d02b8c49f21ef7faa68b7571f93">&#9670;&#160;</a></span>mkdir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1mkdirReturn.html">mkdirReturn</a> JSL::mkdir </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks the status of the target directory, if it does not exist, attempts to create it. Works wherever the <code>mkdir</code> command is installed. <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>Path (relative or absolute) to the desired directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structJSL_1_1mkdirReturn.html" title="A wrapper for the return type of mkdirSafely()">mkdirReturn</a> object detailing the success + associated messages for the request </dd></dl>

</div>
</div>
<a id="a8b19814a4b6cb667d1e27133acc38513" name="a8b19814a4b6cb667d1e27133acc38513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b19814a4b6cb667d1e27133acc38513">&#9670;&#160;</a></span>operator!=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simply returns the inverse of the equality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first matrix</td></tr>
    <tr><td class="paramname">rhs</td><td>the value to be compared to lhs for equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if equal, true if not </dd></dl>

</div>
</div>
<a id="a394a4f9cee0747c76d1190b0365c7b5a" name="a394a4f9cee0747c76d1190b0365c7b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394a4f9cee0747c76d1190b0365c7b5a">&#9670;&#160;</a></span>operator!=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80fcd230a03dd81f1c37fec030619bf9" name="a80fcd230a03dd81f1c37fec030619bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fcd230a03dd81f1c37fec030619bf9">&#9670;&#160;</a></span>operator*() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Naive element-wise scalar multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The value to multiply elements by</td></tr>
    <tr><td class="paramname">rhs</td><td>The matrix to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointwise product of the elements of rhs and the scalar </dd></dl>

</div>
</div>
<a id="ab4eefbed468f275164855895335b8a29" name="ab4eefbed468f275164855895335b8a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4eefbed468f275164855895335b8a29">&#9670;&#160;</a></span>operator*() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Naive element-wise scalar multiplication. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The value to multiply elements by</td></tr>
    <tr><td class="paramname">rhs</td><td>The vector to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointwise product of the elements of rhs and the scalar </dd></dl>

</div>
</div>
<a id="a69548e09ba5835ee87ac4d28907b5435" name="a69548e09ba5835ee87ac4d28907b5435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69548e09ba5835ee87ac4d28907b5435">&#9670;&#160;</a></span>operator*() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias of <a class="el" href="namespaceJSL.html#a5f6c1988cf84b088617e0f12fc1e98da" title="Exactly equivalent to JSL::operator+(const Matrix &amp;lhs, const double &amp;scalar), just swapped around.">JSL::operator+(const double &amp;scalar,const Matrix &amp;rhs)</a> with the operation order swapped around. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The matrix to multiply</td></tr>
    <tr><td class="paramname">scalar</td><td>The value to multiply elements by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointwise product of the elements of lhs and the scalar </dd></dl>

</div>
</div>
<a id="a95d670e99aed43f857d8ba5e6f3d7897" name="a95d670e99aed43f857d8ba5e6f3d7897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d670e99aed43f857d8ba5e6f3d7897">&#9670;&#160;</a></span>operator*() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs standard matix multiplication, (AB)_ij = A_ik B_kj. Only works on matrices of compatible sizes, and left-right ordering matters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left hand size of the multiplication</td></tr>
    <tr><td class="paramname">The</td><td>right hand side of the multiplication </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product lhs * rhs accordingto standard matrix product rules. Size of output is lhs.Rows by rhs.Columns </dd></dl>

</div>
</div>
<a id="a823f5e48d384320644698917c0a1c85c" name="a823f5e48d384320644698917c0a1c85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823f5e48d384320644698917c0a1c85c">&#9670;&#160;</a></span>operator*() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies a vector by the matrix, following the rule (Av)_i = A_ij v_j. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The matrix operating on the matrix</td></tr>
    <tr><td class="paramname">rhs</td><td>The vector to be operated upon </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The product (lhs * rhs), which is a <a class="el" href="classJSL_1_1Vector.html">Vector</a> the same size as rhs </dd></dl>

</div>
</div>
<a id="afc5e092de4a9bdc5795d40ee0f51c7b9" name="afc5e092de4a9bdc5795d40ee0f51c7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5e092de4a9bdc5795d40ee0f51c7b9">&#9670;&#160;</a></span>operator*() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias of <a class="el" href="namespaceJSL.html#ac5ceabb8b9e657c5e2d0faf9b20a36e8" title="Exactly equivalent to JSL::operator+(const Vector &amp;lhs, const double &amp;scalar), just swapped around.">JSL::operator+(const double &amp;scalar,const Vector &amp;rhs)</a> with the operation order swapped around. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The vector to multiply</td></tr>
    <tr><td class="paramname">scalar</td><td>The value to multiply elements by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointwise product of the elements of lhs and the scalar </dd></dl>

</div>
</div>
<a id="a5f6c1988cf84b088617e0f12fc1e98da" name="a5f6c1988cf84b088617e0f12fc1e98da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6c1988cf84b088617e0f12fc1e98da">&#9670;&#160;</a></span>operator+() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exactly equivalent to <a class="el" href="namespaceJSL.html#ad779a68a2d565490f76dd16adfc3091e" title="Adds the value of scalar to every element in the matrix.">JSL::operator+(const Matrix &amp;lhs, const double &amp;scalar)</a>, just swapped around. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar to be added element-wise</td></tr>
    <tr><td class="paramname">rhs</td><td>The matrix to be summed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar + rhs </dd></dl>

</div>
</div>
<a id="ac5ceabb8b9e657c5e2d0faf9b20a36e8" name="ac5ceabb8b9e657c5e2d0faf9b20a36e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ceabb8b9e657c5e2d0faf9b20a36e8">&#9670;&#160;</a></span>operator+() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exactly equivalent to <a class="el" href="namespaceJSL.html#a4b293e2ac3df51113e80022cb3c2ac99" title="Adds the value of scalar to every element in the vector.">JSL::operator+(const Vector &amp;lhs, const double &amp;scalar)</a>, just swapped around. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar to be added element-wise</td></tr>
    <tr><td class="paramname">rhs</td><td>The vector to be summed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scalar + rhs </dd></dl>

</div>
</div>
<a id="ad779a68a2d565490f76dd16adfc3091e" name="ad779a68a2d565490f76dd16adfc3091e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad779a68a2d565490f76dd16adfc3091e">&#9670;&#160;</a></span>operator+() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the value of scalar to every element in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The matrix to be summed</td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar to be added element-wise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix lhs + scalar </dd></dl>

</div>
</div>
<a id="ad1bcc74167579ecff71209bf8c9c47a3" name="ad1bcc74167579ecff71209bf8c9c47a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bcc74167579ecff71209bf8c9c47a3">&#9670;&#160;</a></span>operator+() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs obvious matrix addition (a+b)_ij = a_ij + b_ij. Throws an error if the matrices are not the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first vector to be summed</td></tr>
    <tr><td class="paramname">rhs</td><td>The second vector to be summed (order is irrelevant) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector lhs + rhs </dd></dl>

</div>
</div>
<a id="a4b293e2ac3df51113e80022cb3c2ac99" name="a4b293e2ac3df51113e80022cb3c2ac99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b293e2ac3df51113e80022cb3c2ac99">&#9670;&#160;</a></span>operator+() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the value of scalar to every element in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The vector to be summed</td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar to be added element-wise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector lhs + scalar </dd></dl>

</div>
</div>
<a id="ae6530b77174d0dfae8e0d6e2a810f672" name="ae6530b77174d0dfae8e0d6e2a810f672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6530b77174d0dfae8e0d6e2a810f672">&#9670;&#160;</a></span>operator+() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs obvious vector addition (a+b)_i = a_i + b_i. Throws an error if the vectors are not the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first vector to be summed</td></tr>
    <tr><td class="paramname">rhs</td><td>The second vector to be summed (order is irrelevant) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector lhs + rhs </dd></dl>

</div>
</div>
<a id="aebaffa5dc8073b816908a9708a36b7bf" name="aebaffa5dc8073b816908a9708a36b7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebaffa5dc8073b816908a9708a36b7bf">&#9670;&#160;</a></span>operator-() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A slightly odd operation (included for completeness) - adds the value of scalar to the negative of the elements of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The value which acts as a base</td></tr>
    <tr><td class="paramname">rhs</td><td>The vector which will be subtracted elementwise from the base scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector scalar - rhs </dd></dl>

</div>
</div>
<a id="ab3d17c5cc03a2048e8637d2054fbc138" name="ab3d17c5cc03a2048e8637d2054fbc138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d17c5cc03a2048e8637d2054fbc138">&#9670;&#160;</a></span>operator-() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A slightly odd operation (included for completeness) - adds the value of scalar to the negative of the elements of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The value which acts as a base</td></tr>
    <tr><td class="paramname">rhs</td><td>The vector which will be subtracted elementwise from the base scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector scalar - rhs </dd></dl>

</div>
</div>
<a id="a6d5304adbdadcb062246266f4ece24a1" name="a6d5304adbdadcb062246266f4ece24a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5304adbdadcb062246266f4ece24a1">&#9670;&#160;</a></span>operator-() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the value of scalar to every element in the <a class="el" href="classJSL_1_1Matrix.html">Matrix</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The base matrix</td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar to be subtracted from the base matrix element wise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector lhs - scalar. </dd></dl>

</div>
</div>
<a id="a4f1a2a224c7f6a8c57627b03594cd89f" name="a4f1a2a224c7f6a8c57627b03594cd89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1a2a224c7f6a8c57627b03594cd89f">&#9670;&#160;</a></span>operator-() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs obvious matrix subtraction (a-b)_ij = a_ij - b_ij. Throws an error if the matrices are not the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first vector</td></tr>
    <tr><td class="paramname">rhs</td><td>The vector to be subtracted from the first </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix lhs - rhs </dd></dl>

</div>
</div>
<a id="ac6bd9311dd73aa6227d826bdb94e748d" name="ac6bd9311dd73aa6227d826bdb94e748d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bd9311dd73aa6227d826bdb94e748d">&#9670;&#160;</a></span>operator-() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts the value of scalar to every element in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The base vector</td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar to be subtracted from the base vector element wise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector lhs - scalar. </dd></dl>

</div>
</div>
<a id="a1d8393f2865dc23e7975ad041e341ba5" name="a1d8393f2865dc23e7975ad041e341ba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8393f2865dc23e7975ad041e341ba5">&#9670;&#160;</a></span>operator-() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs obvious vector subtraction (a-b)_i = a_i - b_i. Throws an error if the vectors are not the same size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The base vector</td></tr>
    <tr><td class="paramname">rhs</td><td>The vector to be subtracted from the base vector (order does matter!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The vector lhs - rhs. </dd></dl>

</div>
</div>
<a id="ab1f3153179f59c59a0c2a5e553889eb1" name="ab1f3153179f59c59a0c2a5e553889eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f3153179f59c59a0c2a5e553889eb1">&#9670;&#160;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Matrix.html">Matrix</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Essentially an alias for <a class="el" href="namespaceJSL.html#a5f6c1988cf84b088617e0f12fc1e98da" title="Exactly equivalent to JSL::operator+(const Matrix &amp;lhs, const double &amp;scalar), just swapped around.">JSL::operator+(const double &amp;scalar,const Matrix &amp;rhs)</a> with the scalar set to one-over itself, i.e. pointwise division of the provided matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The matrix to divide</td></tr>
    <tr><td class="paramname">scalar</td><td>The value to divide elements by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointwise divisor of the elements of lhs and the scalar </dd></dl>

</div>
</div>
<a id="a1427fd44260592b7d65d27946969fba1" name="a1427fd44260592b7d65d27946969fba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1427fd44260592b7d65d27946969fba1">&#9670;&#160;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Essentially an alias for <a class="el" href="namespaceJSL.html#ac5ceabb8b9e657c5e2d0faf9b20a36e8" title="Exactly equivalent to JSL::operator+(const Vector &amp;lhs, const double &amp;scalar), just swapped around.">JSL::operator+(const double &amp;scalar,const Vector &amp;rhs)</a> with the scalar set to one-over itself, i.e. pointwise division of the provided vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The vector to divide</td></tr>
    <tr><td class="paramname">scalar</td><td>The value to divide elements by </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointwise divisor of the elements of lhs and the scalar </dd></dl>

</div>
</div>
<a id="a96050c622f5d29373cdc4a5ebb216b47" name="a96050c622f5d29373cdc4a5ebb216b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96050c622f5d29373cdc4a5ebb216b47">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Argument.html">Argument</a>&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides an explicit instruction for how to infer outputting the arg-value. This works (temperamentally) without this function, but strings (well-known for being fiddly here) can sometimes mess it up, so providing explicit instruction works for the best. </p>

</div>
</div>
<a id="a7e357c34e91d1eb03c15ca437a285ea1" name="a7e357c34e91d1eb03c15ca437a285ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e357c34e91d1eb03c15ca437a285ea1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classJSL_1_1Matrix.html#abcf44559767ab6939851f0d3b60c6fa8" title="Converts the matrix to a human-readable string.">JSL::Matrix::to_string()</a> and then passes it to the provided stream, enabling sweet, smooth output such as std::cout &lt;&lt; M &lt;&lt; std::endl. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>An output stream capable of parsing strings</td></tr>
    <tr><td class="paramname">obj</td><td>A <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> object to be inserted into the stream for output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the modified stream </dd></dl>

</div>
</div>
<a id="ad01cc2984ad2ce5a85fb31960835dd04" name="ad01cc2984ad2ce5a85fb31960835dd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01cc2984ad2ce5a85fb31960835dd04">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <a class="el" href="classJSL_1_1Vector.html#a73579b4a194cc924341806a5d9ea3817" title="Converts the vector into a human-readable string.">JSL::Vector::to_string()</a> and then passes it to the provided stream, enabling sweet, smooth output such as std::cout &lt;&lt; v1 &lt;&lt; std::endl. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>An output stream capable of parsing strings</td></tr>
    <tr><td class="paramname">obj</td><td>A vector object to be inserted into the stream for output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the modified stream </dd></dl>

</div>
</div>
<a id="a682c8bb3fff54370f38dcb16794fc7c5" name="a682c8bb3fff54370f38dcb16794fc7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682c8bb3fff54370f38dcb16794fc7c5">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Matrix.html">Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An overloaded equality checker. Checks size, then checks each entry - quick for finding mismatches, but requires full sweep to confirm total equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first matrix</td></tr>
    <tr><td class="paramname">rhs</td><td>the value to be compared to lhs for equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True, if equal, false if not </dd></dl>

</div>
</div>
<a id="a7fad54be308ccb76f68933d91c3c542f" name="a7fad54be308ccb76f68933d91c3c542f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fad54be308ccb76f68933d91c3c542f">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a> <a class="el" href="structJSL_1_1NameValuePair.html">JSL::operator</a>== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="addbf4a35e1d5a856d7c301e1e5829c2f" name="addbf4a35e1d5a856d7c301e1e5829c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbf4a35e1d5a856d7c301e1e5829c2f">&#9670;&#160;</a></span>PipedInputFound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a> JSL::PipedInputFound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An alias for an isatty command, given a easier to remember name. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the program called with piped input (either via | or &lt;). Does not work on Windows. </dd></dl>

</div>
</div>
<a id="a66c1c8f6c27fe101b0731477de5535b7" name="a66c1c8f6c27fe101b0731477de5535b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c1c8f6c27fe101b0731477de5535b7">&#9670;&#160;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> JSL::power </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">double</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac54b96d9c3678069d34aa56f4a3b3a0f" name="ac54b96d9c3678069d34aa56f4a3b3a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54b96d9c3678069d34aa56f4a3b3a0f">&#9670;&#160;</a></span>readPipedInputString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string JSL::readPipedInputString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the most basic readin --&gt; saves the piped input to a string, and returns it. </p>

</div>
</div>
<a id="a28ff6f134180e7d98a22629381cedc1e" name="a28ff6f134180e7d98a22629381cedc1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ff6f134180e7d98a22629381cedc1e">&#9670;&#160;</a></span>rgb_to_hsv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt; JSL::rgb_to_hsv </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt;&#160;</td>
          <td class="paramname"><em>rgb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae48b92e64fb9d321121df976b770efa6" name="ae48b92e64fb9d321121df976b770efa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48b92e64fb9d321121df976b770efa6">&#9670;&#160;</a></span>rm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::rm </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td>
          <td class="paramname"><em>recursive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calls a system-rm on the provided location, and attempts to remove it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The target location on which rm is called </td></tr>
    <tr><td class="paramname">recursive</td><td>If true, appends -r to the command, and so removes all subdirectories etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d104ebd2bbb9ec6eade1abbb59fa84e" name="a1d104ebd2bbb9ec6eade1abbb59fa84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d104ebd2bbb9ec6eade1abbb59fa84e">&#9670;&#160;</a></span>SortIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">typename</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">size_t</a> &gt; JSL::SortIndices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the sorted index array associated with a vector - not the sorted array itself</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A vector of objects where the less than operator is defined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a sorted index-vector y such that v[y[0]] is the smallest value in the array, v[y[1]] is the next, and so on. </dd></dl>

</div>
</div>
<a id="aa37a5ffd99a34e2f12377c9f00b31c50" name="aa37a5ffd99a34e2f12377c9f00b31c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37a5ffd99a34e2f12377c9f00b31c50">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; JSL::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">char</a>&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Splits the string based on the chosen delimiter. Repeated delimiters are ignored. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The input string to be split (unchanged) </td></tr>
    <tr><td class="paramname">delimiter</td><td>The delimiting character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of non-empty strings. </dd></dl>

</div>
</div>
<a id="a5cd4ed117decf1140104ad8566b589ac" name="a5cd4ed117decf1140104ad8566b589ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd4ed117decf1140104ad8566b589ac">&#9670;&#160;</a></span>systemCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::systemCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses C++'s std::system to run a command given by the inpt string, and checks for errors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The command to be executed by the system's default command processor (/bin/bash, cmd.exe etc) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e3dd386e7ab4be6fae6e0bdf8c98e91" name="a6e3dd386e7ab4be6fae6e0bdf8c98e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3dd386e7ab4be6fae6e0bdf8c98e91">&#9670;&#160;</a></span>UpperBoundLocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">int</a> JSL::UpperBoundLocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">double</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>valArray</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to FindXInY except where you do not expect an exact match. Searches through an (assumed sorted) vector and locates the first value greater than or equal to the target value, else returns the index of the final value in the array. </p>

</div>
</div>
<a id="aa7816eb0cd81b74241ce460237990e70" name="aa7816eb0cd81b74241ce460237990e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7816eb0cd81b74241ce460237990e70">&#9670;&#160;</a></span>VectorCrossProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJSL_1_1Vector.html">Vector</a> JSL::VectorCrossProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The standard cross product &ndash; only defined on R^3 (throws an error else) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td><a class="el" href="classJSL_1_1Vector.html">Vector</a> 1</td></tr>
    <tr><td class="paramname">rhs</td><td><a class="el" href="classJSL_1_1Vector.html">Vector</a> 2 (order relevant - using standard conventions <a class="el" href="classJSL_1_1Vector.html">Vector</a> 1 x <a class="el" href="classJSL_1_1Vector.html">Vector</a> 2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classJSL_1_1Vector.html">Vector</a> cross product of inputs </dd></dl>

</div>
</div>
<a id="aeae64b7e0cfdc1ab5f35cca90c32d9f6" name="aeae64b7e0cfdc1ab5f35cca90c32d9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae64b7e0cfdc1ab5f35cca90c32d9f6">&#9670;&#160;</a></span>VectorDotProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">double</a> JSL::VectorDotProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="classJSL_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The standard dot product on R^n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td><a class="el" href="classJSL_1_1Vector.html">Vector</a> 1,</td></tr>
    <tr><td class="paramname">rhs</td><td><a class="el" href="classJSL_1_1Vector.html">Vector</a> 2 (order irrelevant) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum (lhs_i * rhs_i) </dd></dl>

</div>
</div>
<a id="a245ac3bfe113c110491342bf2bb602fc" name="a245ac3bfe113c110491342bf2bb602fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245ac3bfe113c110491342bf2bb602fc">&#9670;&#160;</a></span>writeHeatMapToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> , <a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">R</a> , <a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">S</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::writeHeatMapToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">R</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">S</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>columnDelimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A funciton similar to writeMatrix, but customised to the dumb format required for gnuplot heatmaps with their additional weird linebreak everytime the x-value changes </p>

</div>
</div>
<a id="ae790600d9f16e338cfc8b50cd1bfc8f4" name="ae790600d9f16e338cfc8b50cd1bfc8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae790600d9f16e338cfc8b50cd1bfc8f4">&#9670;&#160;</a></span>writeMatrixToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::writeMatrixToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>contentMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>columnDelimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>rowDelimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As with writeStringToFile and writeVectorToFile, but accepts a vector&lt;vector&gt; of templated entities. The writing loops over the outer vector (the rows), and then at each step, the inner vectors(the columns). Writing them one at a time, separated by the delimiter objects. Objects need not be square matrices to be successfully written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The target file location </td></tr>
    <tr><td class="paramname">contentMatrix</td><td>A vector&lt;vector&gt; of templated objects to be written to file </td></tr>
    <tr><td class="paramname">columnDelimiter</td><td>The character(s) to be written after every individual entry <em>except</em> the final entry in each row </td></tr>
    <tr><td class="paramname">rowRelimiter</td><td>The character(s) to be written at the end of each row <em>including</em> the final row. This will probably be a linebreak! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a425710dc6536490f1c1d6a5ce621f0e3" name="a425710dc6536490f1c1d6a5ce621f0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425710dc6536490f1c1d6a5ce621f0e3">&#9670;&#160;</a></span>writeMultiVectorToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">typename</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::writeMultiVectorToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">Ts</a> &gt; &amp;...&#160;</td>
          <td class="paramname"><em>vecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As with writeVectorToFile, but accepts arbitrary vectors of templated entities. The writing loops over the length of the vectors (which must all be the same length), and writes them sequentially, separated by the delimiter, and a linebreak at the end of each row - i.e v1[0], v2[0], v3[0], ... (linebreak) v1[1], v2[1], ... etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The target file location </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character(s) to be written after every individual vecs entry <em>except</em> the final entry on each row, which is a linebreak. </td></tr>
    <tr><td class="paramname">v1</td><td>The first vector to be written to file </td></tr>
    <tr><td class="paramname">vecs</td><td>A variadic template for any number (including 0) of additional vectors, of any type (said type must have support for the streaming operator, &lt;&lt;). All vecs must be the same length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a838b3a913896993bc008408d164ec19d" name="a838b3a913896993bc008408d164ec19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838b3a913896993bc008408d164ec19d">&#9670;&#160;</a></span>writeStringToFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::writeStringToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opens the provided file and appends the provided string to the file, before closing it. If the file does not exist, it creates it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The target file location </td></tr>
    <tr><td class="paramname">content</td><td>The desired string to be appended to the file (accepts control characters) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d611217d83275af846cbc091ff98f53" name="a1d611217d83275af846cbc091ff98f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d611217d83275af846cbc091ff98f53">&#9670;&#160;</a></span>writeVectorToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structJSL_1_1NameValuePair.html">class</a> <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">void</a> JSL::writeVectorToFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt; <a class="el" href="structJSL_1_1NameValuePair.html">T</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>contentVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>delimiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structJSL_1_1NameValuePair.html">bool</a>&#160;</td>
          <td class="paramname"><em>includeTerminalLineBreak</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As with writeStringToFile, but accepts a vector of templated entities. The writing loops over the vector and writes them one at a time, separated by the delimiter object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The target file location </td></tr>
    <tr><td class="paramname">contentVector</td><td>A vector of templated objects to be written to file </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character(s) to be written after every entry of contentVector <em>except</em> the final entry </td></tr>
    <tr><td class="paramname">includeTerminalLineBreak</td><td>If true, appends a linebreak character at the end of the vector. Useful for sequentially writing rows of data to file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2822caa026c439b483c262bb5edf30aa" name="a2822caa026c439b483c262bb5edf30aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2822caa026c439b483c262bb5edf30aa">&#9670;&#160;</a></span>DEFAULT_TOGGLE_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> <a class="el" href="structJSL_1_1NameValuePair.html">bool</a> JSL::DEFAULT_TOGGLE_VALUE = <a class="el" href="structJSL_1_1NameValuePair.html">false</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a606f5a286ccd4cf3d860d2efde2eac82" name="a606f5a286ccd4cf3d860d2efde2eac82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606f5a286ccd4cf3d860d2efde2eac82">&#9670;&#160;</a></span>ErrorNames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structJSL_1_1NameValuePair.html">const</a> std::vector&lt;std::string&gt; JSL::ErrorNames = {&quot;ERROR&quot;, &quot;SYSTEM <a class="el" href="structJSL_1_1NameValuePair.html">ERROR&quot;</a>, &quot;OVERRUN <a class="el" href="structJSL_1_1NameValuePair.html">ERROR&quot;</a>, &quot;FAILED <a class="el" href="structJSL_1_1NameValuePair.html">ASSERTION&quot;</a>,&quot;IOError&quot;, &quot;GNUPLOT <a class="el" href="structJSL_1_1NameValuePair.html">ERROR&quot;</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
